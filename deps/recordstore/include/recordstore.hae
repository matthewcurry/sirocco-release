/*
 * (C) 2014 The University of Chicago
 *
 * See COPYRIGHT in top-level directory.
 */

#ifndef __RECORDSTORE_HAE__
#define __RECORDSTORE_HAE__

#include <aesop/aesop.h>

/* The recordstore API defines an abstraction for raw storage of
 * records on local storage devices.  It is intended to be used in tandem
 * with a higher level component that indexes records and provides a
 * more user-friendly interface to interact with data and control visibility.
 * The recordstore API will provide very little safety checking on its own.
 *
 * The recordstore supports multiple back-end methods that can be selected at
 * runtime.  For example, different methods may store records in memory, in
 * flat files, or on block devices.  Each method contains whatever
 * optimizations are necessary for that device, including sync coalescing or
 * alignment.
 */

/* rs_instance_t: Used to uniquedly identify an instantiation of the 
 * recordstore.  The same method
 * may be instantiated multiple times (e.g., to provide access to
 * multiple storage devices).  The instance is generated at run time and is
 * not persistent (e.g., it is not portable across reboots or across the 
 * network).
 */
struct rs_instance;
typedef struct rs_instance* rs_instance_t;

/* rs_init(): used to initialize a recordstore instance, specifying what 
 * storage method to use and any
 * parameters needed by that storage method.  A rs_instance_t value equal to
 * NULL indicates a failure.
 *
 * Multiple instances may be active simultaneously.
 *
 * - examples: 
 *    rs_instance_t rsi1, rsi2, rsi3;
 *    rsi1 = rs_init("files", "path:/tmp/rs1,mode:directio,align:4096);
 *    rsi2 = rs_init("files", "path:/tmp/rs2,mode:directio,align:4096);
 *    rsi3 = rs_init("memory", NULL);
 */
rs_instance_t rs_init(const char* method_name, const char* params);


/* general I/O concepts: The API allows writes of contiguous bytes.  
 * Some differences from POSIX writes:
 * - There are no short writes; the operation either suceeds or fails in its
 *   entirety.
 * - There is no true over-write of existing data; you can only write new
 *   records
 * - There are two identifiers for data written into the storage, explained
 *   below
 *
 * The first identifier is specified by the caller and is called the rs_key.  
 * The second identifier is generated by the recordstore and is called the
 * rs_id.  Both identifiers will be used by the caller on subsequent 
 * operations to read, deprecate, or flush a set of records.  The rs_id is
 * intended to be chosen by the recordstore to allow it to find the record
 * later without additional indexing of records.
 *
 * If you write the same rs_key twice, then it will produce two different
 * rs_id values.  The recordstore will never truely overwrite existing data.
 *
 * Semantically the recordstore behaves somewhat like a 
 * content-addressible storage system, though the recordstore isn't 
 * necessarily going to look at the contents of the records.
 *
 * A recordstore implementation is free to ignore the rs_key if it can fit 
 * all identifying information needed to locate the record later in the 
 * rs_id value.  A recordstore implementation may also treat the rs_key as a
 * hint that can be used to group related data together in storage.  For
 * example, a log-structured file-based method may use the first 128 bits of
 * the key to identify objects that should be stored in the same log.
 * 
 * The typical use case for the recordstore will have a higher level
 * component (like the SOS or TOSD) store the rs_key and rs_id values in a
 * database for indexing purposes.
 */
 
typedef struct rs_key {
    char data[32];
} rs_key_t;

typedef struct rs_id {
    char data[32];
} rs_id_t;

/* write a set of contiguous records with a total size of nbytes.
 * buffer is a pointer to the memory to be written.
 *
 * There are no short writes.  This operation either succeeds of fails.
 *
 * returns 0 on success, < 0 on failure.
 *
 * example (write 4 2-byte records to collection 1, object 1, fork 0, record
 * 0)
 *
 * rs_key_t key;
 * rs_id_t id;
 * int ret;
 *
 * key.data[0] = 1;
 * key.data[1] = 1;
 * key.data[2] = 0;
 * key.data[3] = 0;
 *
 * ret = rs_write(instance, key, buffer, 8, &id);
 */
__blocking int rs_write(rs_instance_t ri, rs_key_t key, const void* buffer,
   size_t nbytes, rs_id_t* out_id);

/* Read a set of records previously written with rs_write.  The records are
 * addressed by the rs_key-t and rs_id_t produced by rs_write().
 *
 * Note that at read time we don't indicate (neither with input nor output
 * arguments) how the buffer is divided into records.  We assume that the
 * caller is keeping track of this and knows what to expect.  
 *
 * The reader is allow to read a subset of the bytes that were originally
 * written.  For example, you could rs_write 4 2-byte records (for a
 * total of 8 bytes) but then issue a read of size 5 here, which would
 * produce 2 full records and one partial record).
 *
 * The relative_offset allows the reader to specify an offset relative to
 * the rs_id.  So for example, you could write 1 MB and then read a single
 * byte in the middle by specifying a relative_offset of 512K and a size of
 * 1.
 *
 * There are no short reads; this call either reads all "size" bytes or fails.
 */
__blocking int rs_read(rs_instance_t ri, rs_key_t key, rs_id_t id,
   void* buffer, size_t nbytes, off_t relative_offset); 

/* deprecate: deprecates data that was previously written
 * using rs_write.  A set of records that has been deprecated will no longer
 * be accessible to the caller.
 *
 * There is no way to partially deprecate an rs_id; it is all or nothing.
 *
 * In this context, the deprecate can be thought of as a lazy delete.  It is
 * really a hint to tell the recordstore that the caller never intends to
 * reference those records again.  The recordstore can delete the data
 * immeidately or defer deletion until later at its discretion.
 */
__blocking int rs_deprecate(rs_instance_t ri, rs_key_t key, rs_id_t id);

/* flush: force specified data and all chronologically preceding writes to 
 * durable storage.  This is
 * only valid for instances that a) actually have a durable storage device
 * and b) are not configured to make data durable automatically.
 */
__blocking int rs_flush(rs_instance_t ri, rs_key_t, rs_id_t id);

/* diag: debugging/development routine: will print statistics to stdout for
 * the instance
 */
void rs_diag(rs_instance_t ri);

/* shut down a recordstore */
void rs_finalize(rs_instance_t ri);

/* TODO: potential future functionality:
 *
 * - an optimized call to reorder/flatten/compact existing data.  The caller
 *   would have to express which records need to be merged and in what
 *   order.
 * - a call that will force the recordstore to harvest deprecated data
 *   (flush_deprecate()) or similar)
 */

#endif /* __RECORDSTORE_HAE__ */

/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

