/*
 * (C) 2014 The University of Chicago
 *
 * See COPYRIGHT in top-level directory.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <sys/time.h>

#include <recordstore.hae>

/* maximum number of IO ops to execute in benchmark */
#define RS_MAX_OPS (2*1024*1024)

/* describes the workload to be executed */
struct workload_state
{
    rs_key_t key_array[RS_MAX_OPS];
    rs_id_t id_array[RS_MAX_OPS];
    int count;
    int count_done;
    int index;
};

/* pre-define the I/O accesses to be performed in one big array */
/* NOTE: we could reorder or shuffle this as needed to test different
 * patterns
 */
static void setup_workload(struct workload_state* wkld)
{
    int i;
    uint64_t cofr[4]; /* collection/object/fork/record */

    wkld->count = RS_MAX_OPS;
    wkld->index = 0;
    wkld->count_done = 0;

    /* for now we test accessing a single collection/object/fork but varying
     * the record id
     */
    cofr[0] = 1;
    cofr[1] = 1;
    cofr[2] = 0;
    cofr[3] = 0;
    for(i=0; i<RS_MAX_OPS; i++)
    {
        memcpy(wkld->key_array[i].data, cofr, sizeof(cofr));
        cofr[3]++;
    }

    /* no need to set id_array; it is generated by the recordstore */
}

/* allocate buffers to be used for all I/O operations, one per pbranch */
static char** setup_buffers(size_t buffer_sz, int concurrency)
{
    char** array_of_bufs;
    int i, j;

    array_of_bufs = malloc(sizeof(char*) * concurrency);
    assert(array_of_bufs);

    for(i=0; i<concurrency; i++)
    {
        array_of_bufs[i] = malloc(sizeof(char)*buffer_sz);
        assert(array_of_bufs[i]);
        /* initialize every byte of every buffer to get it paged in */
        for(j=0; j<buffer_sz; j++)
        {
            array_of_bufs[i][j] = '1';
        }
    }

    return(array_of_bufs);
}

static double Wtime(void)
{
    struct timeval t;
    gettimeofday(&t, NULL);
    return((double)t.tv_sec + (double)(t.tv_usec) / 1000000);
}

__blocking int aesop_main(int argc, char **argv)
{
    rs_instance_t ri;
    int ret;
    struct workload_state wkld;
    const char* buffer = NULL;
    size_t buffer_sz;
    double max_time;
    int concurrency;
    char** buffers;
    double start, end;
    pthread_mutex_t wkld_mutex;
    double ops_s;
    double MB_s;

    if(argc != 7)
    {
        fprintf(stderr, "Usage: recordstore-write-bench <method> <options> <access_size_in_bytes> <concurrency> <max_benchmark_time_in_floating_point_seconds> <index_output_file>\n");
        return(-1);
    }

    ret = sscanf(argv[3], "%zd", &buffer_sz);
    if(ret != 1)
    {
        /* TODO: usage error */
        return(-1);
    }

    ret = sscanf(argv[4], "%d", &concurrency);
    if(ret != 1)
    {
        /* TODO: usage error */
        return(-1);
    }

    ret = sscanf(argv[5], "%lf", &max_time);
    if(ret != 1)
    {
        /* TODO: usage error */
        return(-1);
    }
 
    ri = rs_init(argv[1], argv[2]);
    if(ri == NULL)
    {
        fprintf(stderr, "Error: rs_init() failure.\n");
        return(-1);
    }

    /* prepare workload description and memory buffers */
    setup_workload(&wkld);
    buffers = setup_buffers(buffer_sz, concurrency);

    /* start timing */
    start = Wtime();

    pwait
    {
        pprivate int i;
        pprivate int branch_ret;
        pprivate int branch_index = 0;

        for(i=0; i<concurrency; i++)
        {
            pbranch
            {
                while(branch_index < RS_MAX_OPS)
                {
                    pthread_mutex_lock(&wkld_mutex);

                    /* determine what operation we are supposed to issue */
                    branch_index = wkld.index;
                    wkld.index++;

                    /* periodically check time limit */
                    if((wkld.index % 100) == 0)
                    {
                        end = Wtime();
                        if(end - start > max_time)
                            wkld.index = RS_MAX_OPS;
                    }

                    pthread_mutex_unlock(&wkld_mutex);

                    /* have we run out of ops? */
                    if(branch_index >= RS_MAX_OPS)
                    {
                        break;
                    }

                    branch_ret = rs_write(ri, wkld.key_array[branch_index],
                        buffers[i], buffer_sz, &wkld.id_array[branch_index]);
                    assert(branch_ret == 0);                

                    pthread_mutex_lock(&wkld_mutex);
                    wkld.count_done++;
                    pthread_mutex_unlock(&wkld_mutex);

                }

            }
        }
    }

    end = Wtime();

    ops_s = (double)wkld.count_done;
    ops_s /= (end-start);

    MB_s = (double)wkld.count_done * (double)buffer_sz;
    MB_s /= (1024.0 *1024.0);
    MB_s /= (end-start);

    rs_diag(ri);

    printf("ops_completed: %d\n", wkld.count_done);
    printf("ops_second: %f\n", ops_s);
    printf("MiBs_second: %f\n", MB_s);

    rs_finalize(ri);

    /* TODO: write index information to output file */

    return 0;
}
aesop_main_set(aesop_main);

/*
 * Local Variables:
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
